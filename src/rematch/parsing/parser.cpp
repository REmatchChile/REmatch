#include "parsing/parser.hpp"

#include "antlr4-runtime.h"
#include "parsing/visitors/variable_catalog_visitor.hpp"
#include "parsing/visitors/char_class_visitor.hpp"
#include "parsing/error_listener.hpp"
#include "parsing/grammar/autogenerated/REmatchParser.h"
#include "parsing/grammar/autogenerated/REmatchLexer.h"

namespace rematch {
inline namespace parsing {

Parser::Parser(const std::string_view input, bool allow_multi_spanners) {
  create_logical_va(input, allow_multi_spanners);
}

Parser::~Parser() {
  logical_va->destroy();
  logical_va = nullptr;
}

void Parser::create_logical_va(const std::string_view input, bool allow_multi_spanners) {
  ZoneScoped;

  // * Parse Tree
  antlr4::ANTLRInputStream stream(input);
  REmatchLexer lexer(&stream);
  antlr4::CommonTokenStream tokens(&lexer);
  REmatchParser parser(&tokens);
  parser.removeErrorListeners();
  antlr4::ParserErrorListener listener;
  parser.addErrorListener(&listener);
  REmatchParser::RootContext *root = parser.root();

  // Factories
  visitors::VariableCatalogVisitor vfv;
  vfv.set_allow_multi_spanners(allow_multi_spanners);
  vfv.visit(root);
  vfact_ptr = vfv.vfact_ptr;
  visitors::CharClassVisitor ffv(vfact_ptr);

  // LVA creation
  ffv.visit(root);
  std::unique_ptr<LogicalVA> lva_ptr = std::move(ffv.lva_ptr);


  logical_va = std::move(lva_ptr);
}

LogicalVA& Parser::get_logical_va() {
  return *logical_va;
}

std::shared_ptr<VariableCatalog> Parser::get_variable_catalog() {
  return vfact_ptr;
}

}
}
