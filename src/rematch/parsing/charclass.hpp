#ifndef CHARCLASS_BUILDER_HPP
#define CHARCLASS_BUILDER_HPP

#include <set>
#include <string>
#include <ostream>


#include "parsing/grammar/autogenerated/REmatchParser.h"

namespace REmatch {
inline namespace parsing {

struct CharRange {
	CharRange() : lo(0), hi(0) {}
	CharRange(char l, char h): lo(l), hi(h) {}

	bool operator==(const CharRange& rhs) const { return lo == rhs.lo && hi == rhs.hi; }

	char lo;
	char hi;
};

struct CharRangeLess {
	bool operator()(const CharRange &a, const CharRange &b) const {
		return a.hi < b.lo;
	}
};

using CharRangeSet = std::set<CharRange, CharRangeLess>;

class CharClass {

 friend struct std::hash<CharClass>;

 private:
	int nchars;
	CharRangeSet ranges;

 public:
	CharClass();
	// Shorthand constructors
	CharClass(char c);
	CharClass(char l, char h);

	using iterator = CharRangeSet::iterator;
	iterator begin() {return ranges.begin();}
	iterator end() {return ranges.end();}

	void add_charclass(CharClass* cc);
	bool add_range(char l, char h);
	bool add_single(char c);
	void negate();

	CharClass* intersect(CharClass* cc);
	CharClass* set_minus(CharClass* cc);

	int size() const {return nchars;}
	bool empty() const {return nchars == 0;}
	bool contains(char c);
	bool is_dot() const { return nchars == CHAR_MAX+1;}
	bool operator==(const CharClass& rhs) const;

	friend std::ostream& operator<<(std::ostream &os, CharClass const &b);
};

}
}


template<typename T>
inline void hash_combine(std::size_t &seed, T const &v) {
  std::hash<T> hasher;
  seed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
}


// Hashing for the class
namespace std {

template <>
struct hash<REmatch::CharClass> {
  size_t operator()(const REmatch::CharClass& ch) const {

    size_t res = 0;

    for(auto &elem: ch.ranges) {
      hash_combine(res, elem.lo);
      hash_combine(res, elem.hi);
    }

    return res;
  }
};

}

#endif // end charclass_hpp
