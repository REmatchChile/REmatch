.TH "rematch::LogicalVA" 3 "Mon Jan 30 2023" "Version 1" "Rematch" \" -*- nroff -*-
.ad l
.nh
.SH NAME
rematch::LogicalVA
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <logical_va\&.hpp>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBLogicalVAState\fP * \fBinitial_state\fP () const"
.br
.ti -1c
.RI "\fBLogicalVAState\fP * \fBaccepting_state\fP () const"
.br
.ti -1c
.RI "\fBLogicalVA\fP ()"
.br
.ti -1c
.RI "\fBLogicalVA\fP (const \fBLogicalVA\fP &A)"
.br
.ti -1c
.RI "\fBLogicalVA\fP (\fBCharClass\fP charclass)"
.br
.ti -1c
.RI "void \fBtrim\fP ()"
.br
.ti -1c
.RI "void \fBcat\fP (\fBLogicalVA\fP &a2)"
.br
.ti -1c
.RI "void \fBalter\fP (\fBLogicalVA\fP &a2)"
.br
.ti -1c
.RI "void \fBkleene\fP ()"
.br
.ti -1c
.RI "void \fBstrict_kleene\fP ()"
.br
.ti -1c
.RI "void \fBoptional\fP ()"
.br
.ti -1c
.RI "void \fBassign\fP (std::bitset< 64 > open_code, std::bitset< 64 > close_code)"
.br
.ti -1c
.RI "void \fBrepeat\fP (int min, int max)"
.br
.ti -1c
.RI "void \fBremove_captures\fP ()"
.br
.ti -1c
.RI "void \fBremove_epsilon\fP ()"
.br
.ti -1c
.RI "void \fBrelabel_states\fP ()"
.br
.ti -1c
.RI "bool \fBhas_epsilon\fP () const"
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "std::vector< \fBLogicalVAState\fP * > \fBstates\fP"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "class \fBExtendedVA\fP"
.br
.ti -1c
.RI "std::ostream & \fBoperator<<\fP (std::ostream &os, \fBLogicalVA\fP const &A)"
.br
.in -1c
.SH "Constructor & Destructor Documentation"
.PP 
.SS "rematch::LogicalVA::LogicalVA ()"

.SS "rematch::LogicalVA::LogicalVA (const \fBLogicalVA\fP & A)"

.SS "rematch::LogicalVA::LogicalVA (\fBCharClass\fP charclass)"

.SH "Member Function Documentation"
.PP 
.SS "\fBLogicalVAState\fP * rematch::LogicalVA::accepting_state () const\fC [inline]\fP"

.SS "void rematch::LogicalVA::alter (\fBLogicalVA\fP & a2)"

.SS "void rematch::LogicalVA::assign (std::bitset< 64 > open_code, std::bitset< 64 > close_code)"

.SS "void rematch::LogicalVA::cat (\fBLogicalVA\fP & a2)"

.SS "bool rematch::LogicalVA::has_epsilon () const\fC [inline]\fP"

.SS "\fBLogicalVAState\fP * rematch::LogicalVA::initial_state () const\fC [inline]\fP"

.SS "void rematch::LogicalVA::kleene ()"

.SS "void rematch::LogicalVA::optional ()"

.SS "void rematch::LogicalVA::relabel_states ()"

.SS "void rematch::LogicalVA::remove_captures ()"

.SS "void rematch::LogicalVA::remove_epsilon ()"

.SS "void rematch::LogicalVA::repeat (int min, int max)"

.SS "void rematch::LogicalVA::strict_kleene ()"

.SS "void rematch::LogicalVA::trim ()"
Transforms the automaton graph to a trimmed automaton\&. This being that every state is reacheable from the initial state, and the final state is reachable from every state\&. We'll do a simple BFS from the initial and final states (using backwards transitions), storing the states that are reached by both procedures
.SH "Friends And Related Function Documentation"
.PP 
.SS "friend class ExtendedVA\fC [friend]\fP"

.SS "std::ostream & operator<< (std::ostream & os, \fBLogicalVA\fP const & A)\fC [friend]\fP"

.SH "Member Data Documentation"
.PP 
.SS "std::vector<\fBLogicalVAState\fP*> rematch::LogicalVA::states"


.SH "Author"
.PP 
Generated automatically by Doxygen for Rematch from the source code\&.
